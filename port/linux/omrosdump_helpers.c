/*******************************************************************************
 * Copyright (c) 1991, 2022 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
 * or the Apache License, Version 2.0 which accompanies this distribution and
 * is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * This Source Code may also be made available under the following
 * Secondary Licenses when the conditions for such availability set
 * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
 * General Public License, version 2 with the GNU Classpath
 * Exception [1] and GNU General Public License, version 2 with the
 * OpenJDK Assembly Exception [2].
 *
 * [1] https://www.gnu.org/software/classpath/license.html
 * [2] http://openjdk.java.net/legal/assembly-exception.html
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
 *******************************************************************************/

/**
 * @file
 * @ingroup Port
 * @brief Dump formatting
 */

#include <sys/mman.h>
#include <sys/param.h>
#include <sys/stat.h>
#if defined(LINUX)
#include <sys/prctl.h>
#include <sys/procfs.h>
#include <sys/resource.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#endif
#include <elf.h>
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <dirent.h>

#include "portnls.h"
#include "omrosdump_helpers.h"

#define MAX_PTR_SIZE_BYTES 8

static intptr_t waitCore(char *path);
static void setChecksumMarkAllPagesWritableHeader(MarkAllPagesWritableHeader *header);
static char linuxMemoryMapsFile[] = "/proc/self/maps";
static uintptr_t getSharedAndPrivateDataSegments(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, uint8_t **ppStart, uint8_t **ppEnd, char *flags, long *fileOff, char *filePath);

static uintptr_t readElfHeader(struct OMRPortLibrary *portLibrary, intptr_t fd, Elf64_Ehdr *pElfheader);
static uintptr_t findProgramHeader(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, Elf64_Off phoff, Elf64_Half phnum, uint8_t *start, uint8_t *end);
static void copyDataIntoELFCore(struct OMRPortLibrary *portLibrary, intptr_t fd_core, uintptr_t addrSize, Elf64_Off phoff);
static intptr_t getContentsFromProcFileSystem(struct OMRPortLibrary *portLibrary, const char *fileName, char *buffer, size_t buflen);
static void insertSharedAndPrivateDataSegments(struct OMRPortLibrary *portLibrary, char *corePath);
static intptr_t deriveCoreFileName(struct OMRPortLibrary *portLibrary, char *corePatternFormat, BOOLEAN coreUsesPID, char *baseDir, char *derivedCoreFileName, uintptr_t derivedCoreFileNameLen, pid_t pid, int signalNumber);

#ifdef DUMP_DBG
static void printMemoryMap(struct OMRPortLibrary *portLibrary, uintptr_t addrSize);
static void printProgramHeader(struct OMRPortLibrary *portLibrary, uintptr_t addrSize, void *pelfPgmHdr, uintptr_t count);
static void printProgramHeaders(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, Elf64_Off phoff, Elf64_Half phnum);
#endif

/* @internal
 *
 * @param[in]   fileName    absolute path of name of file to open
 * @param[out]  buffer      user allocated buffer to write contents to
 * @param[in]   bufLen      the size of @ref buffer.
 *
 * @return:
 *  1 file does not exist
 *  0 file exists and buffer contains the contents.
 *  negative value on error (in which case there was a problem looking for or opening the file).
*/
static intptr_t
getContentsFromProcFileSystem(struct OMRPortLibrary *portLibrary, const char *fileName, char *buffer, size_t buflen)
{
	J9FileStat j9fstat;
	int32_t j9fstatRc;
	intptr_t fd;

	buffer[0] = '\0';
	j9fstatRc = portLibrary->file_stat(portLibrary, fileName, 0, &j9fstat);
	if (0 == j9fstatRc) {
		if (0 == j9fstat.isFile) {
			/* file does not exist */
			return 1;
		} else {
			/* file exists */
			fd = portLibrary->file_open(portLibrary, fileName, EsOpenRead, 0);

			if (fd != -1) {
				intptr_t bytesRead;

				bytesRead = portLibrary->file_read(portLibrary, fd, buffer, buflen);

				if (bytesRead != -1) {
					/* we've read the contents of the file */
					return 0;
				}
			}
		}
	}

	return -1;
}

/*
 * @internal
 *
 * Figures out what the system core file name that was generated by the child process will be
 *  according to man core{5}, then renames it to @ref filename.
 *
 *  Note that the %t token in core_pattern is not supported.
 *
 *  If @ref filename is an empty string, renameDump writes in the name of the OS-generated core file.
 *
 * @param[in]
 * @param[in]   filename    user-allocated buffer of size EsMaxPath containing the desired core filename
 * @param[out]  filename    on success, the name of the generated core file, otherwise, the error message
 * @param[in]   pid         pid of process that generated the core file.
 *
 * @return 0 on success, otherwise non-zero and @ref filename contains error message.
 *
 * @note: This relies on the child process having created the core file in the directory specified by @ref filename,
 * or the cwd if @ref filename was empty. */
uintptr_t
renameDump(struct OMRPortLibrary *portLibrary, char *filename, pid_t pid, int signalNumber)
{
	char tempPath[PATH_MAX];
	char corePatternFormat[PATH_MAX];
	char coreUsesPIDBuffer[PATH_MAX];
	char derivedAbsoluteCorePath[PATH_MAX];
	const char *corePatternFileName = "/proc/sys/kernel/core_pattern";
	const char *coreUsesPIDFileName = "/proc/sys/kernel/core_uses_pid";
	BOOLEAN coreUsesPID = FALSE;
	intptr_t procRC = -1;
	intptr_t waitCoreRC = -1;
	char *lastSep = NULL;
	intptr_t createCoreFileNameRC = 0;
	intptr_t renameRC = -1;
	struct stat attrBuf;

	memset(corePatternFormat, 0, sizeof(corePatternFormat));

	if (getenv("J9_USER_DUMP")) {
		return stat(filename, &attrBuf);
	}

	procRC = getContentsFromProcFileSystem(portLibrary, corePatternFileName, corePatternFormat, PATH_MAX);
	if (0 == procRC) {
		/* corePatternFormat contains format, strip out the '\n' */
		char *newLine = strchr(corePatternFormat, '\n');
		if (NULL != newLine) {
			*newLine = '\0';
		}
		if ('|' == corePatternFormat[0]) {
			/*
			 * core pattern is being used to pipe the core file to a tool such as ABRT. In
			 * this case, the file is in core.<pid>
			 */
			portLibrary->nls_printf(portLibrary, J9NLS_WARNING | J9NLS_STDERR, J9NLS_PORT_LINUXDUMP_PIPE_CORE, corePatternFileName, corePatternFormat, pid);
			strncpy(corePatternFormat, "core", PATH_MAX);
		}
	} else if (1 == procRC) {
		/* corePatternFileName does not exist (it should be there from kernel 2.5 onwards), use the default core file name */
		strncpy(corePatternFormat, "core", PATH_MAX);
	} else {
		/* there was an error opening corePatternFileName */
		portLibrary->str_printf(portLibrary, filename, EsMaxPath, "Error opening \"%s\". Look for core file generated by child process with pid = %i", corePatternFileName, pid);
		return 1;
	}

	procRC = getContentsFromProcFileSystem(portLibrary, coreUsesPIDFileName, coreUsesPIDBuffer, PATH_MAX);
	if (0 == procRC) {
		/* coreUsesPIDBuffer contains ascii representation of 0 or non-zero value */
		if (0 != atoi(coreUsesPIDBuffer)) {
			coreUsesPID = TRUE;
		}
	} else if (1 == procRC) {
		/* coreUsesPIDFileName does not exist, we should not get here */
	} else {
		/* there was an error opening coreUsesPIDFileName */
		portLibrary->str_printf(portLibrary,
								filename,
								EsMaxPath,
								"Error opening \"%s\". Look for core file generated by child process with pid = %i",
								coreUsesPIDFileName,
								pid);
		return 1;
	}

	/* determine base directory */
	lastSep = filename ? strrchr(filename, DIR_SEPARATOR) : NULL;
	if (NULL != lastSep) {
		/* filename was an absolute path: strip it down to the directory name, make sure to preserve the trailing front slash */
		size_t charsToCopy = lastSep - filename + 1;

		strncpy(tempPath, filename, charsToCopy);
		tempPath[charsToCopy] = '\0';
	} else {
		*tempPath = '\0';
	}

	/* If we got here there were no errors getting the contents of core_pattern and core_uses_pid */
	createCoreFileNameRC = deriveCoreFileName(portLibrary, corePatternFormat, coreUsesPID, tempPath, derivedAbsoluteCorePath, PATH_MAX, pid, signalNumber);

	if (0 != createCoreFileNameRC) {
		/* we could not derive the name from core_pattern */
		portLibrary->str_printf(portLibrary,
								filename,
								EsMaxPath,
								"Unable to derive system core filename from pattern in %s: \"%s\". "
								"%s"
								" Look for core file generated by child process with pid = %i",
								corePatternFileName,
								corePatternFormat,
								derivedAbsoluteCorePath,
								pid);
		return 1;
	}

	/* wait until the core file is created, or timeout */
	waitCoreRC = waitCore(derivedAbsoluteCorePath);
	if (0 != waitCoreRC) {
		/* the core file does not exist, bail */
		portLibrary->str_printf(portLibrary,
								filename,
								EsMaxPath,
								"The core file created by child process with pid = %i was not found. Expected to find core file with name \"%s\"",
								pid,
								derivedAbsoluteCorePath);
		return 1;
	}

	/* at this point we know the file in derivedCorePath exists */

#ifdef DUMP_DBG
	{
		/* In the parent process, check that the coredump_filter is not present on this system. If it is,
		 * then the child process will have set it to force the automatic inclusion of the shared classes
		 * cache. In that case we need do nothing. If the file is not present then go forth and copy the
		 * unmapped shared cache segments into the core file.
		 */
		intptr_t filter = portLibrary->file_open(portLibrary, "/proc/self/coredump_filter", EsOpenRead, 0);
		if (filter != -1) {
			portLibrary->file_close(portLibrary, filter);
			portLibrary->tty_err_printf(portLibrary, "found /proc/self/coredump_filter\n");
		} else {
			portLibrary->tty_err_printf(portLibrary, "didn't find /proc/self/coredump_filter\n");
		}
	}
#endif

	/* Check that the path we found was to a regular file (not to an existing directory, pipe, symlink etc) */
	if (stat(derivedAbsoluteCorePath, &attrBuf) == 0) {
		if (!S_ISREG(attrBuf.st_mode)) {
			portLibrary->nls_printf(portLibrary, J9NLS_ERROR | J9NLS_STDERR, J9NLS_PORT_DUMP_PATH_EXISTS, derivedAbsoluteCorePath);
			return 1;
		}
	} else {
		portLibrary->str_printf(portLibrary, filename, EsMaxPath, "Unable to read file status for core file path \"%s\"", derivedAbsoluteCorePath);
		return 1;
	}

	/* In all cases, attempt to insert the extra segments of memory needed for a complete core
	 * file image. The insertion process should only add memory segments that have a program
	 * header, but no data in the core file itself. */
	insertSharedAndPrivateDataSegments(portLibrary, derivedAbsoluteCorePath);

	/* Rename the file as required by the specified (or default) -Xdump agent file option */
	if ('\0' == filename[0]) {
		/* filename is empty */
		portLibrary->str_printf(portLibrary, filename, EsMaxPath, "%s", derivedAbsoluteCorePath);
	} else {
		renameRC = rename(derivedAbsoluteCorePath, filename);

		if ((0 != renameRC) && (errno == EXDEV)) { /* failed with 'cross device rename error' */
			memset(tempPath, 0, PATH_MAX);
			/* we retry leaving the dump directory location unchanged */
			lastSep = strrchr(derivedAbsoluteCorePath, DIR_SEPARATOR);
			if (NULL != lastSep) {
				size_t charsToCopy = lastSep - derivedAbsoluteCorePath + 1;
				strncpy(tempPath, derivedAbsoluteCorePath, charsToCopy);
			}
			/* using the dump agent requested file name */
			lastSep = strrchr(filename, DIR_SEPARATOR);
			if (NULL != lastSep) {
				strcat(tempPath, lastSep + 1);
			} else {
				strcat(tempPath, filename);
			}
			/* message warning that the -Xdump option was not fully honoured */
			portLibrary->tty_printf(portLibrary, "Warning: unable to move dump to \"%s\" across file systems (check kernel core_pattern). Using alternate file location \"%s\"\n",
									filename, tempPath);
			/* copy the new file destination back into the supplied filename for the RAS messages */
			portLibrary->str_printf(portLibrary, filename, EsMaxPath, "%s", tempPath);
			renameRC = rename(derivedAbsoluteCorePath, filename);
		}

		if (0 != renameRC) {
			portLibrary->tty_printf(portLibrary, "Attempt to rename \"%s\" to \"%s\" failed with error: %s\n", derivedAbsoluteCorePath, filename, strerror(errno));
			return 1;
		}
	}

	return 0;
}

/*
 * @internal Parse the corePatternString following the rules from the linux man pages, replace the tokens and store the
 * resulting absolute path core file in corePath.
 *
 * If corePatterFormat does not contain %p and coreUsesPID is TRUE, append the PID to the formatted core file name.
 *
 * If corePatternString does not specify an absolute path and and baseDir is not empty, use the absolute path in baseDir as the base directory for the core file.
 *
 *      %%  A single % character
 *      %p  PID of dumped process
 *      %u  real UID of dumped process
 *      %g  real GID of dumped process
 *      %s  number of signal causing dump
 *      %t  time of dump (seconds since 0:00h, 1 Jan 1970)
 *      %h  hostname (same as 'nodename' returned by uname(2))
 *      %e  executable filename
 *
 *  Note: We cannot determine the exact time of the dump, as set by the OS. If we find a %t token, and %p is also specified, we use a wildcard to
 *        obtain a filename match. The child process PID provides reasonable confidence that we will find the correct dump. Otherwise return failure.
 *  Note: From the man pages: "A single % at the end of the template is dropped from the core filename, as is the combination of a % followed by any character other than those listed above."
 *
 * If we cannot reasonably infer what the fileName should be, return -1
 *
 * @param[in] corePatternFormat the null-terminated string, with no line delimiters, representing the format of the core file name.
 *                                  - if there was no core_pattern file, corePatternFormat should be empty string.
 * @param[in] coreUsesPID       TRUE indicates that core_uses_pid indicated that the PID should be appended to the filename
 * @param[in] baseDir           the null-terminated string indicating the absolute path (with trailing dir separator) of the base directory to use if corePatternFormat does not
 *                                  specify an absolute path.
 *                                  - should be empty string if no baseDirectory was specified.
 *
 * @param[out] derivedCoreFileName user-allocated buffer containing the constructed absolute path.
 *                  - derivedCoreFileName will always contain a null-terminated string.
 *                  - On success, derivedCoreFileName contains the name of the core file.
 *                  - On failure, derivedCoreFileName contains a message detailing the cause.
 * @param[in]   corePathLen the size of the buffer @ref corePath.
 * @param[in]   pid the process ID of the child process that triggered the core file generation.
 */
static intptr_t
deriveCoreFileName(struct OMRPortLibrary *portLibrary, char *corePatternFormat, BOOLEAN coreUsesPID, char *baseDir, char *derivedCoreFileName, uintptr_t derivedCoreFileNameLen, pid_t pid, int signalNumber)
{
	char *inCursor = corePatternFormat;
	char *outCursor = derivedCoreFileName;
	BOOLEAN corePatternSpecifiesPercentP = FALSE;
	int numWildcards = 0;
	intptr_t charsPrinted = 0;
	char scratchSpace[PATH_MAX];

	while ('\0' != *inCursor) {
		uintptr_t bytesLeft = derivedCoreFileNameLen - (outCursor - derivedCoreFileName);
		charsPrinted = 0;

		switch (*inCursor) {
		case '%':
			inCursor++;
			switch (*inCursor) {
			case '%':
				/* literal '%' */
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%%");
				break;
#if defined(LINUX)
			case 'c':
				{
					struct rlimit limit = {0};
					int rc = getrlimit(RLIMIT_CORE, &limit);
					if (-1 == rc) {
						portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "%s", "Failed to obtain core limit");
						return -1;
					}
					charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%lu", limit.rlim_cur);
				}
				break;
			case 'd':
				{
					int dumpableFlag = prctl(PR_GET_DUMPABLE, scratchSpace);
					if (0 > dumpableFlag) {
						charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%d", dumpableFlag);
					} else {
						portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "%s", "Failed to obtain dumpable flag");
						return -1;
					}
				}
				break;
			case 'P':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", "*");
				++numWildcards;
				break;
			case 'E':
				{
					char *pathSep = NULL;
					int readlinkRc = readlink("/proc/self/exe", scratchSpace, PATH_MAX);

					if (-1 == readlinkRc) {
						portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "readlink() on \"/proc/self/exe\" failed: %s", scratchSpace, strerror(errno));
						return -1;
					}
					scratchSpace[readlinkRc] = '\0';

					pathSep = strchr(scratchSpace, DIR_SEPARATOR);
					while (NULL != pathSep) {
						*pathSep = '!';
						pathSep = strchr(pathSep, DIR_SEPARATOR);
					}
					charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", scratchSpace);
				}
				break;
			case 'I':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", "*");
				++numWildcards;
				break;
#endif
			case 'i':
				/* Forked process will have only 1 thread, thus TID == PID */
				/* Intentionall fall through */
			case 'p':
				corePatternSpecifiesPercentP = TRUE;
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%i", pid);
				break;
			case 'u':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%u", portLibrary->sysinfo_get_euid(portLibrary));
				break;
			case 'g':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%u", portLibrary->sysinfo_get_egid(portLibrary));
				break;
			case 's':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%i", signalNumber);
				break;
			case 'h':
				if (-1 != gethostname(scratchSpace, PATH_MAX)) {
					charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", scratchSpace);
					break;
				} else {
					portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "%s", "Failed to obtain hostname");
					return -1;
				}
			case 'e':
#if defined(LINUX)
#ifndef PR_GET_NAME
#define PR_GET_NAME 16
#endif
				/* thread name is at most 16 bytes long, in which case it is not null-terminated. */
				if (prctl(PR_GET_NAME, scratchSpace) >= 0) {
					/*
					 * the function is supported and succeeded.
					 * scratchSpace contains the thread name, which is null terminated if shorter than 16 bytes.
					 */
					scratchSpace[16] = '\0'; /* ensure the name is terminated by a null if it is exactly 16 bytes long */
					charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", scratchSpace);
				} else
#endif
				{
					char *lastSep, *startExeName;
					int readlinkRc = readlink("/proc/self/exe", scratchSpace, PATH_MAX);

					if (-1 == readlinkRc) {
						portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "readlink() on \"/proc/self/exe\" failed: %s", scratchSpace, strerror(errno));
						return -1;
					}
					scratchSpace[readlinkRc] = '\0';
					lastSep = strrchr(scratchSpace, DIR_SEPARATOR);
					if (NULL == lastSep) {
						startExeName = scratchSpace;
					} else {
						startExeName = lastSep + 1;
					}
					charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", startExeName);
				}
				break;
			case 't':
				charsPrinted = portLibrary->str_printf(portLibrary, outCursor, bytesLeft, "%s", "*");
				++numWildcards;
				break;
			default:
				/* unknown token, skip */
				charsPrinted = 0;
			}
			break;
		default:
			*outCursor = *inCursor;
			charsPrinted = 1;
		}
		outCursor = outCursor + charsPrinted;
		inCursor++;
	}
	*outCursor = '\0';

	if ((0 < numWildcards) && !corePatternSpecifiesPercentP) {
		/* no PID in the filename, indicate unsupported dump pattern and bail out*/
		portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "%s", "\"%t\",\"%P\",\"%I\"  specifiers are not supported without \"%p\".");
		return -1;
	}

	if (1 < numWildcards) {
		portLibrary->str_printf(portLibrary, derivedCoreFileName, PATH_MAX, "%s", "only one instance of \"%t\",\"%P\", or\"%I\"  is supported.");
		return -1;
	}

	/* do we need to append with the PID? */
	if (!corePatternSpecifiesPercentP && coreUsesPID) {
		charsPrinted = portLibrary->str_printf(portLibrary, outCursor, derivedCoreFileNameLen - (outCursor - derivedCoreFileName), ".%i", pid);
		/*outCursor = outCursor + charsPrinted;*/
	}

	/* if derivedCoreFileName does not specify an absolute path, use the one provided in baseDir (if there is one)
	 * - check for directory separator in derivedCoreFileName
	 */
	if (('\0' != *baseDir) && (NULL == strchr(derivedCoreFileName, '/'))) {
		charsPrinted = portLibrary->str_printf(portLibrary, scratchSpace, PATH_MAX, "%s%s", baseDir, derivedCoreFileName);
		memcpy(derivedCoreFileName, scratchSpace, charsPrinted + 1);
	}

	return 0;
}

/**
 * Wait for the core dump file to be written..
 *
 * @param[in] path  absolute path of the expected core file, null terminated, maximum length including null is PATH_MAX.
 *                  the filename portion of the path may contain a single '*' wildcard.
 *
 * @return intptr_t 0 if the file was found, otherwise 1 indicating timeout while looking for the file
 *
 */
static intptr_t
waitCore(char *path)
{
	int rc = 1;
	time_t starttime;
	FILE *fd;
	starttime = time(NULL);
	char *wildcardPos = strchr(path, '*'); /* position of '*' wildcard, if any, in the expected core dump filename */

	if (NULL == wildcardPos) {
		/* Normal case, no wildcard in the dump filename. Wait for the expected dump file to appear, using
		 * fopen() to check whether the file exists.
		 */
		while (0 != rc) {
			fd = fopen(path, "r");
			if (NULL == fd) {
				/* could not open the file */
				rc = 1;
				if (difftime(time(NULL), starttime) > 5) {
					break;
				}
				usleep(100000);
			} else {
				/* opened the file successfully, so we know it exists, now close it */
				fclose(fd);
				rc = 0;
			}
		}
	} else {
		/* Special case, wildcard in the dump filename. Wait for the expected dump file to appear, listing
		 * files in the core dump directory to look for a file name that matches the expected core dump name.
		 */
		char *pathSeparator = strrchr(path, DIR_SEPARATOR); /* locate the end of the directory path */
		if (NULL == pathSeparator) {
			return rc; /* error, we should have an absolute path, bail out */
		}
		*pathSeparator = '\0'; /* truncate the path at the end of the last directory */
		*wildcardPos = '\0'; /* also truncate the core dump file name at the wild card */

		while (0 != rc) {
			struct dirent *entry = NULL;
			/* Open the directory in which we expect to find the core dump */
			DIR *coreDirectory = opendir(path);
			if (NULL == coreDirectory) {
				break; /* error, we should have a good directory path, bail out */
			}

			/* Search the directory for a matching file */
			while (NULL != (entry = readdir(coreDirectory))) {
				char *filename = entry->d_name;
				/* Check for a match for both halves of the expected core dump file name */
				if (strstr(filename, pathSeparator + 1) && strstr(filename, wildcardPos + 1)) {
					/* Good match, fix up the supplied core dump file name using the actual file name */
					if (strlen(path) + strlen(filename) + 2 <= PATH_MAX) { /* overflow check */
						strcpy(pathSeparator + 1, filename);
						rc = 0; /* success */
					}
					break;
				}
			}
			closedir(coreDirectory);

			/* If no matching file name was found, loop and repeat until timeout */
			if (0 != rc) {
				if (difftime(time(NULL), starttime) > 5) {
					break; /* timeout */
				}
				usleep(100000);
			}
		}
		*pathSeparator = DIR_SEPARATOR; /* restore the path separator */
		if (0 != rc) {
			*wildcardPos = '*'; /* restore the wildcard character, on failure only */
		}
	}
	return rc;
}

static void
setChecksumMarkAllPagesWritableHeader(MarkAllPagesWritableHeader *header)
{
	void *end_ptr = (void *)(header + 1);
	int32_t sum = 0;
	int32_t *ptr = (int32_t *)header;
	header->checksum = 0;
	while ((void *)ptr < end_ptr) {
		sum ^= *ptr++;
	}
	header->checksum = sum;
}

/**
 * @internal  read /proc/self/maps to determine what pages are mapped for this process.
 * Modify each page to be writable. This will cause it to be included in core dumps.
 *
 * The format of /proc/self/maps is:
 *   40000000-40013000 r-xp 00000000 03:03 1161002    /lib/ld-2.2.5.so
 *   40013000-40014000 rw-p 00013000 03:03 1161002    /lib/ld-2.2.5.so
 *   40014000-40016000 rw-p 00000000 00:00 0
 * ...
 *
 * This implementation expects the format to be strictly conformed to.
 * If deviations in the format are discovered, we'll have to make this routine
 * more robust.
 *
 * See also CMVC 107677. On Linux 2.6, using mprotect while reading
 * /proc/self/maps can cause the contents of the file to change beneath us.
 * In particular, consecutive identical entries can be coalesced. To avoid this
 * we make multiple passes over the file. We stop when we no longer discover
 * any pages that can be modified or when we've made log2(n) passes,
 * where n is the number of pages. At worst we'll miss less than half of the
 * pages on each pass, so log2(n) is the upper bound on the number of passes.
 *
 * CMVC 128452 Where we are running a JVM compiled as a 32 bit application
 * on a 64 bit linux, the buffer for reading data from /proc/self/maps was too
 * short. Its length has now been increased to accomodate the wider data. On 32 bit
 * the minimum line length is sufficient to allow us to read more than we need.
 *
 * CMVC 150400: As this is in a linux child process, only the failing thread
 * will have been maintained. Any locks taken by other threads cannot be unlocked
 * by this one. Hence the use of native file IO in markAllPagesWritable to avoid the
 * mutex in memory check and a potential hang.
 */

char *
markAllPagesWritable(struct OMRPortLibrary *portLibrary)
{
	BOOLEAN modified = TRUE;
	uintptr_t log2N = (sizeof(void *) * 8) - 12; /* assume 4096 byte pages */
	uintptr_t pass;

	MarkAllPagesWritableHeader *buffer = (MarkAllPagesWritableHeader *) portLibrary->portGlobals->procSelfMap;

	/* Record proc/self/maps file into the pre-allocated buffer before changing the pages to writable */
	/* Nothing should be changing any more as this fork is frozen and will die */

	/* CMVC 150400 We are using native file io calls here to avoid the mutex in the memcheck library. */
	if (buffer != NULL) {
		FILE *fd = fopen(linuxMemoryMapsFile, "r");
		if (fd != NULL) {
			/* Gratuitous xors prevent the eyecatcher constant from appearing in the code */
			uint32_t eyeCatcher = J9OSDUMP_EYECATCHER ^ 0xffffffff;
			char *bufferData = (char *)(buffer + 1);
			char readBuffer[1];
			buffer->eyeCatcher = eyeCatcher ^ 0xffffffff;
			buffer->size = 0;
			buffer->maxSize = J9OSDUMP_SIZE - sizeof(MarkAllPagesWritableHeader);

			while ((fread(readBuffer, 1, 1, fd) == 1) && (buffer->size < buffer->maxSize)) {
				*bufferData++ = readBuffer[0];
				(buffer->size)++;
			}
			fclose(fd);
			setChecksumMarkAllPagesWritableHeader(buffer);
		}
	}

	for (pass = 0; modified && (pass < log2N); pass++) {
		FILE *fd = fopen(linuxMemoryMapsFile, "r");

		modified = FALSE;

		if (fd != NULL) {
			/* buf is big enough to fit the address range and permissions for 32 & 64 bit */
			char buf[MAX_PTR_SIZE_BYTES * 4 + sizeof("- rwxp")];
			while (fread(buf, 1, sizeof(buf) - 1, fd) == sizeof(buf) - 1) {
				char *next;
				uint8_t *start, *end;
				int rc;
				int prot = 0;

				/*
				 * we've now read into buf:
				 * for 32 bit: something like "40000000-40013000 r-xp"
				 * for 64 bit: something like "0000002a95893000-0000002a95894000 rw-p"
				 */

				/* NUL terminate buf for extra safety */
				buf[sizeof(buf) - 1] = '\0';

				/* use strtoull for correctness on 64-bit platforms and gratuitous extra precision on 32-bit platforms */
				start = (uint8_t *)(uintptr_t)strtoull(buf, &next, 16);

				/* skip the '-' */
				next += 1;

				end = (uint8_t *)(uintptr_t)strtoull(next, &next, 16);

				if (strchr(next, 'r')) {
					prot |= PROT_READ;
				}
				if (strchr(next, 'w')) {
					prot |= PROT_WRITE;
				}
				if (strchr(next, 'x')) {
					prot |= PROT_EXEC;
				}
				if (0 == (prot & PROT_WRITE)) {
					/* mark the pages as writable */
					rc = mprotect(start, end - start, prot | PROT_WRITE);
					if (rc == 0) {
						modified = TRUE;
					}
				}

				/* skip to the next line */
				while (fread(buf, 1, 1, fd) == 1) {
					if (buf[0] == '\n') {
						break;
					}
				}
			}
			fclose(fd);
		}
	}

	return (char *) buffer;
}

#ifdef DUMP_DBG
static void
printProgramHeader(struct OMRPortLibrary *portLibrary, uintptr_t addrSize, void *pelfPgmHdr, uintptr_t count)
{
	Elf32_Phdr *p32elfPgmHdr = NULL;
	Elf64_Phdr *p64elfPgmHdr = NULL;

	if (32 == addrSize) {
		p32elfPgmHdr = (Elf32_Phdr *)pelfPgmHdr;
		portLibrary->tty_printf(portLibrary, "===32 bit=== ====pgmhdr# %d====\n", count);
		portLibrary->tty_printf(portLibrary, "p_offset %d\n", p32elfPgmHdr->p_offset);
		portLibrary->tty_printf(portLibrary, "p_vaddr %lx\n", p32elfPgmHdr->p_vaddr);
		portLibrary->tty_printf(portLibrary, "p_paddr %lx\n", p32elfPgmHdr->p_paddr);
		portLibrary->tty_printf(portLibrary, "p_filesz %d\n", p32elfPgmHdr->p_filesz);
		portLibrary->tty_printf(portLibrary, "p_memsz %ld\n", p32elfPgmHdr->p_memsz);
		portLibrary->tty_printf(portLibrary, "p_align %ld\n", p32elfPgmHdr->p_align);
	} else if (64 == addrSize) {
		p64elfPgmHdr = pelfPgmHdr;
		portLibrary->tty_printf(portLibrary, "===64 bit=== ====pgmhdr# %d====\n", count);
		portLibrary->tty_printf(portLibrary, "p_offset %d\n", p64elfPgmHdr->p_offset);
		portLibrary->tty_printf(portLibrary, "p_vaddr %llx\n", p64elfPgmHdr->p_vaddr);
		portLibrary->tty_printf(portLibrary, "p_paddr %llx\n", p64elfPgmHdr->p_paddr);
		portLibrary->tty_printf(portLibrary, "p_filesz %d\n", p64elfPgmHdr->p_filesz);
		portLibrary->tty_printf(portLibrary, "p_memsz %lld\n", p64elfPgmHdr->p_memsz);
		portLibrary->tty_printf(portLibrary, "p_align %lld\n", p64elfPgmHdr->p_align);
	}
}

static void
printProgramHeaders(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, Elf64_Off phoff, Elf64_Half phnum)
{
	uintptr_t count = 0;
	int position;

	Elf64_Phdr  elfPgmHdr;
	Elf32_Phdr *p32elfPgmHdr = (Elf32_Phdr *)&elfPgmHdr;
	Elf64_Phdr *p64elfPgmHdr = &elfPgmHdr;

	/* run through the program headers until we find a matching program header. */

	/* remember the original position */
	position = portLibrary->file_seek(portLibrary, fd, 0, EsSeekCur);

	/* set the start position */
	J9_IGNORE_RETURNVAL(portLibrary->file_seek(portLibrary, fd, phoff, EsSeekSet));

	if (32 == addrSize) {
		for (count = 0; count < phnum; count++) {
			J9_IGNORE_RETURNVAL(portLibrary->file_read(portLibrary, fd, p32elfPgmHdr, sizeof(Elf32_Phdr)));
			printProgramHeader(portLibrary, 32, (Elf64_Phdr *)p32elfPgmHdr, count);
		}
	} else if (64 == addrSize) {
		for (count = 0; count < phnum; count++) {
			J9_IGNORE_RETURNVAL(portLibrary->file_read(portLibrary, fd, p64elfPgmHdr, sizeof(Elf64_Phdr)));
			printProgramHeader(portLibrary, 64, p64elfPgmHdr, count);
		}
	}
	/* reset the original position */
	position = portLibrary->file_seek(portLibrary, fd, position, EsSeekSet);
}

static void
printMemoryMap(struct OMRPortLibrary *portLibrary, uintptr_t addrSize)
{
	int32_t fd = portLibrary->file_open(portLibrary, linuxMemoryMapsFile, EsOpenRead, 0);
	char ch;
	char outbuf[256];
	int32_t outcursor = 0;
	int32_t bytesRead = 0;
	char *next;
	uint8_t *start = 0;
	uint8_t *end = 0;
	char flags[5];
	char path[256];

	memset(outbuf, '\0', sizeof(outbuf));

	if (fd != -1) {
		portLibrary->tty_printf(portLibrary, "Memory Map:\n");
		while (bytesRead > -1) {
			bytesRead = portLibrary->file_read(portLibrary, fd, &ch, sizeof(ch));
			if (bytesRead > 0) {
				outbuf[outcursor] = ch;
				if (ch == '\n') {
					/* process the entire line */
					outbuf[outcursor] = '\0';
					outcursor = 0;
					path[0] = '\0';

					/* use strtoull for correctness on 64-bit platforms and gratuitous extra precision on 32-bit platforms */
					start = (uint8_t *)(uintptr_t)strtoull(outbuf, &next, 16);

					/* skip the '-' */
					next++;

					end = (uint8_t *)(uintptr_t)strtoull(next, &next, 16);

					/* get the flags as a string */
					next++;
					flags[0] = *next;
					next++;
					flags[1] = *next;
					next++;
					flags[2] = *next;
					next++;
					flags[3] = *next;
					flags[4] = '\0';

					/* get the offset */
					next++;
					J9_IGNORE_RETURNVAL(strtoull(next, &next, 16));

					/* skip over the device (+5) and get the inode (+1) */
					next += 6;
					J9_IGNORE_RETURNVAL(strtoull(next, &next, 10));

					/* get the path */
					while (isspace(*next)) {
						/* eat up leading whitespace */
						next++;
					}
					strcpy(path, next);

					if (32 == addrSize) {
						portLibrary->tty_printf(portLibrary, "%lx %lx %s %s\n", start, end, flags, path);
					} else if (64 == addrSize) {
						portLibrary->tty_printf(portLibrary, "%llx %llx %s %s\n", start, end, flags, path);
					}
				} else {
					outcursor++;
				}
			}
		}
		portLibrary->file_close(portLibrary, fd);
	}
}
#endif

/**
 * @internal  read from a passed file descriptor to locate the
 * details of a memory segments that are used by the process.
 * The fd must already be opened on /proc/self/maps for this to
 * work. Repeated calls should return details of each segment in
 * turn. When no more segments are available, the function will
 * return a false (0) value.
 *
 * @param[in] portLibrary The port library.
 * @param[in] fd The opened file descriptor for the maps file .
 * @param[in] addrSize Size of the machine addresses.
 * @param[out] ppStart address of start ptr.
 * @param[out] ppEnd address of end ptr.
 * @param[out] flags flags of the segment, needs to be array of size 4, can be NULL if not needed
 * @param[out] fileOff offset in mapped file, can be NULL if not needed
 * @param[out] filePath string representing filepath, size EsMaxPath, can be NULL if not needed
 *
 * @return non zero on success, zero otherwise.
 */
static uintptr_t
getSharedAndPrivateDataSegments(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, uint8_t **ppStart, uint8_t **ppEnd, char *flags, long *fileOff, char *filePath)
{
	char ch;
	char outbuf[EsMaxPath];
	char path[EsMaxPath];
	int32_t outcursor = 0;
	int32_t bytesRead = 0;
	uint8_t *start;
	uint8_t *end;
	char attr_flag;
	char *next;
	uintptr_t rc = 0;

	memset(outbuf, '\0', sizeof(outbuf));

	if (fd != -1) {
		while (bytesRead > -1) {
			bytesRead = portLibrary->file_read(portLibrary, fd, &ch, sizeof(ch));
			if (bytesRead > 0) {
				outbuf[outcursor] = ch;
				if ('\n' == ch) {
					/* process the entire line */
					outbuf[outcursor] = '\0';
					outcursor = 0;

					path[0] = '\0';

					/* use strtoull for correctness on 64-bit platforms and gratuitous extra precision on 32-bit platforms */
					start = (uint8_t *)(uintptr_t)strtoull(outbuf, &next, 16);

					/* skip the '-' */
					next++;

					end = (uint8_t *)(uintptr_t)strtoull(next, &next, 16);

					if (NULL == flags) {
						/* skip the read flag */
						next++;
						/* skip the write flag */
						next++;
						/* skip the exec flag */
						next++;
						/* get the attr flag */
						next++;
						attr_flag = *next;
					} else {
						/* get the read flag */
						next++;
						flags[0] = *next;
						/* get the write flag */
						next++;
						flags[1] = *next;
						/* get the exec flag */
						next++;
						flags[2] = *next;
						/* get the attr flag */
						next++;
						flags[3] = *next;
						attr_flag = *next;
					}

					if ('s' == attr_flag || 'p' == attr_flag) {
						/* found a shared or private memory segment */

						/* get the offset */
						next++;
						if (NULL != fileOff) {
							*fileOff = strtoull(next, &next, 16);
						} else {
							J9_IGNORE_RETURNVAL(strtoull(next, &next, 16));
						}

						/* skip over the device (+5) and get the inode (+1) */
						next += 6;
						J9_IGNORE_RETURNVAL(strtoull(next, &next, 10));

						/* get the path */
						while (isspace(*next)) {
							/* eat up leading whitespace */
							next++;
						}
						strcpy(path, next);
						if (NULL != filePath) {
							strcpy(filePath, path);
						}

#ifdef DUMP_DBG
						if (32 == addrSize) {
							portLibrary->tty_printf(portLibrary, "found Shared/Private mem: %s 0x%lx->0x%lx\n", path, start, end);
						} else if (64 == addrSize) {
							portLibrary->tty_printf(portLibrary, "found Shared/Private mem: %s 0x%llx->0x%llx\n", path, start, end);
						}
#endif
						*ppStart = start;
						*ppEnd = end;
						rc = 1;
						break;
					}
				} else {
					outcursor++;
				}
			}
		}
	}
	return rc;
}

/**
 * @internal read data from the passed file descriptor to determine if the file is a valid ELF file.
 *
 * @param[in] portLibrary The port library.
 * @param[in] fd The opened file descriptor for the core file .
 * @param[out] pElfHeader Address of an ELF header structure to populate.
 *
 * @return zero on error, and the machine size the core file was generated for on success (32 or 64).
 */
static uintptr_t
readElfHeader(struct OMRPortLibrary *portLibrary, intptr_t fd, Elf64_Ehdr *pElfHeader)
{
	/* read the Elf magic number and class */
	int count = 0;
	char magic[4] = {'\177', 'E', 'L', 'F'};

	Elf32_Ehdr *p32elfHeader = (Elf32_Ehdr *)pElfHeader;
	Elf64_Ehdr *p64elfHeader = pElfHeader;

	/* set position to the start of the file. */
	portLibrary->file_seek(portLibrary, fd, 0, EsSeekSet);

	/* read for the length of the ELF identifier. */
	count = portLibrary->file_read(portLibrary, fd, pElfHeader, EI_NIDENT);

	if (count == EI_NIDENT) {
		/* read the correct number of bytes. */
		if (memcmp(pElfHeader->e_ident, magic, sizeof(magic)) == 0) {
			/* magic number is correct, we've got an ELF file. */
			if (1 == pElfHeader->e_ident[EI_CLASS]) {
				/* it's for a 32 bit machine. */
				/* now read the rest of the header. */
				count = portLibrary->file_read(portLibrary, fd, &p32elfHeader->e_type, sizeof(Elf32_Ehdr) - EI_NIDENT);
				return 32;
			} else if (2 == pElfHeader->e_ident[EI_CLASS]) {
				/* it's for a 64 bit machine. */
				/* now read the rest of the header. */
				count = portLibrary->file_read(portLibrary, fd, &p64elfHeader->e_type, sizeof(Elf64_Ehdr) - EI_NIDENT);
				return 64;
			}
		}
	}
	return 0;
}

/**
 * @internal locate a program header within an ELF file that fits within the start and end addresses.
 *
 * @param[in] portLibrary The port library.
 * @param[in] fd The opened file descriptor for the core file .
 * @param[in] addrSize Size of the machine addresses.
 * @param[in] phoff Offset of the program headers in the ELF file.
 * @param[in] phnum Number of program headers in the ELF file.
 * @param[in] start Start address to search for.
 * @param[in] end End address to search for.
 *
 * @return zero on error, and the offset of a matching program header on success.
 */
static uintptr_t
findProgramHeader(struct OMRPortLibrary *portLibrary, intptr_t fd, uintptr_t addrSize, Elf64_Off phoff, Elf64_Half phnum, uint8_t *start, uint8_t *end)
{
	uintptr_t count;
	uintptr_t offset = 0;
	uintptr_t bytesread = 0;

	Elf64_Phdr  elfPgmHdr;
	Elf32_Phdr *p32elfPgmHdr = (Elf32_Phdr *)&elfPgmHdr;
	Elf64_Phdr *p64elfPgmHdr = &elfPgmHdr;

	/* run through the program headers until we find a matching program header. */

	/* set the start position */
	offset = portLibrary->file_seek(portLibrary, fd, phoff, EsSeekSet);

	for (count = 0; count < phnum; count++) {
		if (32 == addrSize) {
			/* handle 32 bit machines */
			bytesread = portLibrary->file_read(portLibrary, fd, p32elfPgmHdr, sizeof(Elf32_Phdr));
			if (p32elfPgmHdr->p_vaddr >= (uintptr_t)start && p32elfPgmHdr->p_vaddr <= (uintptr_t)end) {
#ifdef DUMP_DBG
				portLibrary->tty_printf(portLibrary, "%s", "program header found:\n");
				printProgramHeader(portLibrary, 32, p32elfPgmHdr, count);
#endif
				return offset;
			}
		} else if (64 == addrSize) {
			/* handle 64 bit machines */
			bytesread = portLibrary->file_read(portLibrary, fd, p64elfPgmHdr, sizeof(Elf64_Phdr));
			if (p64elfPgmHdr->p_vaddr >= (uintptr_t)start && p64elfPgmHdr->p_vaddr <= (uintptr_t)end) {
#ifdef DUMP_DBG
				portLibrary->tty_printf(portLibrary, "%s", "program header found:\n");
				printProgramHeader(portLibrary, 64, p64elfPgmHdr, count);
#endif
				return offset;
			}
		}
		offset += bytesread;
	}

	/* didn't find a matching header */
	return 0;
}

/**
 * @internal Copy data from memory segments into an ELF
 * core file and update the appropriate program header.
 *
 * @param[in] portLibrary The port library.
 * @param[in] fd_core File handle to the open core file
 * @param[in] addrSize The machine word size in bits
 * @param[in] phoff Offset of the program header being updated
 *
 * @return void.
 */
static void
copyDataIntoELFCore(struct OMRPortLibrary *portLibrary, intptr_t fd_core, uintptr_t addrSize, Elf64_Off phoff)
{
	intptr_t dataOffset;
	intptr_t dataSize;

	Elf64_Phdr  elfPgmHdr;
	Elf32_Phdr *p32elfPgmHdr = (Elf32_Phdr *)&elfPgmHdr;
	Elf64_Phdr *p64elfPgmHdr = &elfPgmHdr;

	if (32 == addrSize) {
		/* read the 32bit program header to see if it needs updating. */
		portLibrary->file_seek(portLibrary, fd_core, phoff, EsSeekSet);
		portLibrary->file_read(portLibrary, fd_core, p32elfPgmHdr, sizeof(Elf32_Phdr));

		if (0 == p32elfPgmHdr->p_filesz) {
			/* the memory is not included in the file, so copy it to the end and update the 32bit program header. */

			/* copy the data to the end of the core file. */
			dataOffset = portLibrary->file_seek(portLibrary, fd_core, 0, EsSeekEnd);
			if (dataOffset != -1) {
				dataSize = portLibrary->file_write(portLibrary, fd_core, (const void *)(uintptr_t)p32elfPgmHdr->p_vaddr, p32elfPgmHdr->p_memsz);
				if (dataSize > 0) {
					/* set up the 32bit program header with filesize, offset and memory size. */
					p32elfPgmHdr->p_filesz = p32elfPgmHdr->p_memsz;
					p32elfPgmHdr->p_offset = dataOffset;

					/* write the 32bit program header back into the core file. */
					portLibrary->file_seek(portLibrary, fd_core, phoff, EsSeekSet);
					portLibrary->file_write(portLibrary, fd_core, p32elfPgmHdr, sizeof(Elf32_Phdr));
				}
			}
		}
	} else if (64 == addrSize) {
		/* read the 64bit program header to see if it needs updating. */
		portLibrary->file_seek(portLibrary, fd_core, phoff, EsSeekSet);
		portLibrary->file_read(portLibrary, fd_core, p64elfPgmHdr, sizeof(Elf64_Phdr));

		if (0 == p64elfPgmHdr->p_filesz) {
			/* the memory is not included in the file, so copy it to the end and update the 64bit program header. */

			/* copy the data to the end of the core file. */
			dataOffset = portLibrary->file_seek(portLibrary, fd_core, 0, EsSeekEnd);
			if (dataOffset != -1) {
				dataSize = portLibrary->file_write(portLibrary, fd_core, (const void *)(uintptr_t)p64elfPgmHdr->p_vaddr, p64elfPgmHdr->p_memsz);
				if (dataSize > 0) {
					/* set up the 64bit program header with filesize, offset and memory size. */
					p64elfPgmHdr->p_filesz = p64elfPgmHdr->p_memsz;
					p64elfPgmHdr->p_offset = dataOffset;

					/* write the 64bit program header back into the core file. */
					portLibrary->file_seek(portLibrary, fd_core, phoff, EsSeekSet);
					portLibrary->file_write(portLibrary, fd_core, p64elfPgmHdr, sizeof(Elf64_Phdr));
				}
			}
		}
	}
}

/**
 * @internal Insert any unmapped memory segments used by
 * the process into the core file.
 *
 * @param[in] portLibrary The port library.
 * @param[in] corepath Full path to the core file.
 * @param[in] cachePath Full path to the shared classes
 * cache file.
 *
 * @return void.
 */
void
insertSharedAndPrivateDataSegments(struct OMRPortLibrary *portLibrary, char *corePath)
{
	intptr_t fd_maps = 0;
	intptr_t fd_core = 0;
	uintptr_t addrSize;

	uint8_t *start;
	uint8_t *end;

	Elf64_Ehdr  elfHeader;
	Elf32_Ehdr *p32elfHeader = (Elf32_Ehdr *)&elfHeader;
	Elf64_Ehdr *p64elfHeader = &elfHeader;

	Elf64_Off  phoff;
	Elf64_Half phnum;
	Elf64_Off  phoff_update = 0;

	/* open the maps file so we can look at the memory segments. */
	fd_maps = portLibrary->file_open(portLibrary, linuxMemoryMapsFile, EsOpenRead, 0);
	if (fd_maps != -1) {
		/* maps file opened ok, now open the core file so we can edit it. */
		fd_core = portLibrary->file_open(portLibrary, corePath, EsOpenWrite | EsOpenRead, 0);
		if (fd_core != -1) {
			/* core file opened ok, now get the shared classes cache file details */
			addrSize = readElfHeader(portLibrary, fd_core, &elfHeader);
			if (32 == addrSize) {
				/* get offset to program headers and number of program headers for 32 bit core. */
				phoff = p32elfHeader->e_phoff;
				phnum = p32elfHeader->e_phnum;
			} else if (64 == addrSize) {
				/* get offset to program headers and number of program headers for 64 bit core. */
				phoff = p64elfHeader->e_phoff;
				phnum = p64elfHeader->e_phnum;
			} else {
				/* the core file is corrupt, continuing is futile, so close files and return. */
				portLibrary->file_close(portLibrary, fd_core);
				portLibrary->file_close(portLibrary, fd_maps);
				return;
			}

#ifdef DUMP_DBG
			printMemoryMap(portLibrary, addrSize);
#endif
			/* read all the shared classes segments */
			while (getSharedAndPrivateDataSegments(portLibrary, fd_maps, addrSize, &start, &end, NULL, NULL, NULL)) {
				/* find a program header that represents this data */
				phoff_update = findProgramHeader(portLibrary, fd_core, addrSize, phoff, phnum, start, end);
				if (0 == phoff_update) {
					/* cannot find the program header that represents this shared classes segment */
					/* obviously this is an error but there is little we can do other than carry on */
					/* processing the rest of the segments. */
#ifdef DUMP_DBG
					if (32 == addrSize) {
						portLibrary->tty_printf(portLibrary, "could not find ELF pgmhdr to match SC mem: 0x%lx->0x%lx\n", start, end);
					} else if (64 == addrSize) {
						portLibrary->tty_printf(portLibrary, "could not find ELF pgmhdr to match SC mem: 0x%llx->0x%llx\n", start, end);
					}
#endif
				} else {
					/* we have a program header to work with. if the ph shows the data is not in the core */
					/* copy the data and update the program header */
					copyDataIntoELFCore(portLibrary, fd_core, addrSize, phoff_update);
				}
			}

#ifdef DUMP_DBG
			portLibrary->tty_printf(portLibrary, "program headers after update\n");
			printProgramHeaders(portLibrary, fd_core, addrSize, phoff, phnum);
#endif

			/* close the core file. */
			portLibrary->file_close(portLibrary, fd_core);
		}
		/* close the maps file. */
		portLibrary->file_close(portLibrary, fd_maps);
	}
}

/* gathers memory segment information from the map file and allocates an array
 * to to pass the segment info to the core dump function
 * returns non zero on success, zero on failure
 */
static int
list_segment_headers(struct OMRPortLibrary *portLibrary, int addrsize, void **segment_headers, uint32_t *segment_count)
{
#ifdef _LP64
	Elf64_Phdr *segments = NULL;
	Elf64_Phdr *tmp_segments = NULL;
#else
	Elf32_Phdr *segments = NULL;
	Elf32_Phdr *tmp_segments = NULL;
#endif
	pid_t ppid = getppid();
	uint32_t segment_array_size = 128;
	int fd_maps = 0;
	char mapfile_name[32] = "/proc/";
	uint8_t *start_addr = 0;
	uint8_t *end_addr = 0;
	char vmmap_flags[4];
	uint32_t pagesize = sysconf(_SC_PAGESIZE);
	int rc = 0;

	snprintf(mapfile_name + 6, 32 - 6, "%d/maps", ppid);
	fd_maps = open(mapfile_name, O_RDONLY, 0);
	if (fd_maps < 0) {
		perror("open() on memory map");
		goto error;
	}

	*segment_count = 0;
	segments = calloc(segment_array_size, sizeof(*segments));
	if (NULL == segments) {
		perror("no memory to list core memory segments");
		goto error;
	}

	while (getSharedAndPrivateDataSegments(portLibrary, fd_maps, addrsize, &start_addr, &end_addr, vmmap_flags, NULL, NULL)) {
		if (*segment_count >= segment_array_size) {
			segment_array_size += segment_array_size / 2;
			tmp_segments = calloc(segment_array_size, sizeof(*tmp_segments));
			if (NULL == tmp_segments) {
				perror("no memory to list core memory segments");
				goto error;
			}
			memcpy(tmp_segments, segments, *segment_count * sizeof(*tmp_segments));
			free(segments);
			segments = tmp_segments;
			tmp_segments = NULL;
		}

		segments[*segment_count].p_type = PT_LOAD;
		segments[*segment_count].p_offset = 0;
		segments[*segment_count].p_vaddr = (Elf64_Addr)start_addr;
		segments[*segment_count].p_paddr = 0;
		segments[*segment_count].p_filesz = 0;
		segments[*segment_count].p_memsz = (Elf64_Addr)end_addr - (Elf64_Addr)start_addr;
		segments[*segment_count].p_flags = 0;
		if ('r' == vmmap_flags[0]) {
			segments[*segment_count].p_flags |= PF_R;
		}
		if ('w' == vmmap_flags[1]) {
			segments[*segment_count].p_flags |= PF_W;
		}
		if ('x' == vmmap_flags[2]) {
			segments[*segment_count].p_flags |= PF_X;
		}
		segments[*segment_count].p_align = pagesize;

		*segment_count += 1;
	}

	*segment_headers = segments;
	rc = 1;

error:
	if ((0 == rc) && (NULL != segments)) {
		free(segments);
	}
	if (fd_maps > 0) {
		close(fd_maps);
	}
	return rc;
}

/* writes data portion of an auxv note
 * returns non zero on success, zero on failure
 */
static int
write_note_auxv_data(int outfile_fd, off_t *outfile_off, unsigned int *data_size)
{
	pid_t ppid = getppid();
	char proc_filename[32] = "/proc/";
	int proc_fd = 0;
	off_t file_off = *outfile_off;
	ssize_t written = 0;
	ssize_t bytes_read = 0;
	long auxv_entry[2]; /* elem 0 is identifier, elem 1 is data */

	snprintf(proc_filename + 6, 32 - 6, "%d/auxv", ppid);
	proc_fd = open(proc_filename, O_RDONLY, 0);
	if (proc_fd < 0) {
		perror("open() on /proc/pid/auxv");
		goto error;
	}

	do {
		bytes_read = read(proc_fd, auxv_entry, sizeof auxv_entry);
		if (bytes_read > 0) {
			written = pwrite(outfile_fd, auxv_entry, sizeof auxv_entry, file_off);
			if (written < 0) {
				perror("writing auxv note to core");
				goto error;
			}
			file_off += written;
			*data_size += written;
		} else if (bytes_read < 0) {
			perror("reading /proc/pid/auxv file");
			goto error;
		}
	} while (bytes_read > 0);
	*outfile_off = file_off;

error:
	if (proc_fd > 0) {
		close(proc_fd);
	}
	return file_off = *outfile_off;
}

/* helper to read a "word", which is anything between whitespace from the /proc/$pid/stat
 * file and stores it into a character array passed from a parameter
 */
static int
read_word_from_stat(int file_fd, char *buffer)
{
	char ch = 0;
	char local_buffer[EsMaxPath] = {0};
	ssize_t bytes_read = 0;
	int index = 0;
	int rc = 0;

	if (file_fd > 0) {
		while (bytes_read > -1) {
			bytes_read = read(file_fd, &ch, 1);
			if (bytes_read <= 0) {
				break;
			}
			if (isspace(ch)) {
				if (0 == index) {
					continue;
				} else {
					break;
				}
			} else {
				local_buffer[index++] = ch;
			}
		}
		if (bytes_read > -1) {
			local_buffer[index++] = '\0';
			if (NULL != buffer) {
				memcpy(buffer, local_buffer, index);
			}
			rc = 1;
		}
		else {
			perror("reading /proc/pid/stat file");
		}
	}
	return rc;
}

/* reads process info from /proc filesystem into the prpsinfo and prstatus structures
 * returns non zero on success, zero on failure
 */
static int
gather_process_data(int outfile_fd, prpsinfo_t *prpsinfo, prstatus_t *prstatus)
{
	pid_t ppid = getppid();
	char proc_filename[32] = "/proc/";
	int proc_fd = 0;
	size_t bytes_read = 0;
	char read_buffer[EsMaxPath];

	snprintf(proc_filename + 6, 32 - 6, "%d/stat", ppid);
	proc_fd = open(proc_filename, O_RDONLY, 0);
	if (proc_fd < 0) {
		perror("open() on /proc/pid/stat");
		return 0;
	}

	/* fill out prpsinfo and general process prstatus info */
	prpsinfo->pr_uid = getuid();
	prpsinfo->pr_gid = getgid();
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_pid = strtol(read_buffer, NULL, 0);
		prstatus->pr_pid = prpsinfo->pr_pid;
	}
	if (read_word_from_stat(proc_fd, read_buffer)) {
		strncpy(prpsinfo->pr_fname, read_buffer, 16);
		prpsinfo->pr_fname[15] = '\0';
	}
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_sname = read_buffer[0];
		prpsinfo->pr_zomb = ('Z' == prpsinfo->pr_sname);
	}
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_ppid = strtol(read_buffer, NULL, 0);
		prstatus->pr_ppid = prpsinfo->pr_ppid;
	}
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_pgrp = strtol(read_buffer, NULL, 0);
		prstatus->pr_pgrp = prpsinfo->pr_pgrp;
	}
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_sid = strtol(read_buffer, NULL, 0);
		prstatus->pr_sid = prpsinfo->pr_sid;
	}
	read_word_from_stat(proc_fd, NULL); /* skip tty_nr */
	read_word_from_stat(proc_fd, NULL); /* skip tpgid */
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_flag = strtol(read_buffer, NULL, 0);
	}
	read_word_from_stat(proc_fd, NULL); /* skip minflt */
	read_word_from_stat(proc_fd, NULL); /* skip cminflt */
	read_word_from_stat(proc_fd, NULL); /* skip majflt */
	read_word_from_stat(proc_fd, NULL); /* skip cmajflt */
	read_word_from_stat(proc_fd, NULL); /* skip utime */
	read_word_from_stat(proc_fd, NULL); /* skip stime */
	read_word_from_stat(proc_fd, NULL); /* skip cutime */
	read_word_from_stat(proc_fd, NULL); /* skip cstime */
	read_word_from_stat(proc_fd, NULL); /* skip priority */
	if (read_word_from_stat(proc_fd, read_buffer)) {
		prpsinfo->pr_nice = strtol(read_buffer, NULL, 0);
	}
	close(proc_fd);

	snprintf(proc_filename + 6, 32 - 6, "%d/cmdline", ppid);
	proc_fd = open(proc_filename, O_RDONLY, 0);
	if (proc_fd < 0) {
		perror("open() on /proc/pid/cmdline");
		return 0;
	}

	bytes_read = read(proc_fd, read_buffer, ELF_PRARGSZ);
	if (bytes_read > 0) {
		strncpy(prpsinfo->pr_psargs, read_buffer, ELF_PRARGSZ);
	}
	prpsinfo->pr_psargs[ELF_PRARGSZ - 1] = '\0';

	if (proc_fd > 0) {
		close(proc_fd);
	}
	return 1;
}

static int
write_thread_notes(int addrsize, int outfile_fd, off_t *outfile_off, prstatus_t *global_prstatus) {
	char corename[8] = "CORE"; /* size 8 for alignment */
	off_t file_off = *outfile_off;
#ifdef _LP64
	Elf64_Nhdr note_hdr = {};
#else
	Elf32_Nhdr note_hdr = {};
#endif
	pid_t ppid = getppid();
	char taskdir_filename[32] = "/proc/";
	DIR *proc_taskdir = NULL;
	int procfile_fd = 0;
	struct dirent *taskdirent = NULL;
	long clock_ticks = sysconf(_SC_CLK_TCK);
	int rc = 0;

	snprintf(taskdir_filename + 6, 32 - 6, "%d/task", ppid);
	proc_taskdir = opendir(taskdir_filename);
	if (NULL == proc_taskdir) {
		perror("opening task dir for process");
		goto done;
	}

	while ((0 == (errno = 0)) && (NULL != (taskdirent = readdir(proc_taskdir)))) {
		if (DT_DIR == taskdirent->d_type) {
			int i = 0;
			pid_t tid = strtoul(taskdirent->d_name, NULL, 0);
			char thread_procfile[64] = {0};
			siginfo_t thread_siginfo;
			prgregset_t gen_regs;
			prfpregset_t fpregs;
			prstatus_t thread_prstatus = *global_prstatus;
			char read_buffer[EsMaxPath] = {0};
			ssize_t written = 0;

			/* skip directories that do not convert to thread ids */
			if (tid < 1) {
				continue;
			}

			snprintf(thread_procfile, 64, "%s/%d/stat", taskdir_filename, tid);
			procfile_fd = open(thread_procfile, O_RDONLY, 0);
			if (procfile_fd < 0) {
				perror("open() on thread stat file");
				goto done;
			}

			/* skip first 13 entries in stat file */
			for (i=0; i < 13; i++) {
				read_word_from_stat(procfile_fd, NULL);
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_utime.tv_sec = strtoul(read_buffer, NULL, 0) / clock_ticks;
				thread_prstatus.pr_utime.tv_usec = thread_prstatus.pr_utime.tv_sec * 1000;
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_stime.tv_sec = strtoul(read_buffer, NULL, 0) / clock_ticks;
				thread_prstatus.pr_stime.tv_usec = thread_prstatus.pr_stime.tv_sec * 1000;
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_cutime.tv_sec = strtoul(read_buffer, NULL, 0) / clock_ticks;
				thread_prstatus.pr_cutime.tv_usec = thread_prstatus.pr_cutime.tv_sec * 1000;
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_cstime.tv_sec = strtoul(read_buffer, NULL, 0) / clock_ticks;
				thread_prstatus.pr_cstime.tv_usec = thread_prstatus.pr_cstime.tv_sec * 1000;
			}
			/* skip entries again until signal entry in stat file */
			for (i=17; i < 32; i++) {
				read_word_from_stat(procfile_fd, NULL);
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_sigpend = strtoul(read_buffer, NULL, 0);
			}
			if (read_word_from_stat(procfile_fd, read_buffer)) {
				thread_prstatus.pr_sighold = strtoul(read_buffer, NULL, 0);
			}

			close(procfile_fd);

			errno = 0;
			if (-1 == ptrace(PTRACE_GETSIGINFO, ppid, NULL, &thread_siginfo)) {
				perror("PTRACE_GETSIGINFO on thread failed");
				goto thread_done;
			}
			errno = 0;
			if (-1 == ptrace(PTRACE_GETREGS, ppid, NULL, &gen_regs)) {
				perror("PTRACE_GETREGS on thread failed");
				goto thread_done;
			}
			errno = 0;
			if (-1 == ptrace(PTRACE_GETFPREGS, ppid, NULL, &fpregs)) {
				perror("PTRACE_GETFPREGS on thread failed");
				goto thread_done;
			}
			memcpy(thread_prstatus.pr_reg, gen_regs, sizeof thread_prstatus.pr_reg);
			thread_prstatus.pr_info.si_signo = thread_siginfo.si_signo;
			thread_prstatus.pr_info.si_code = thread_siginfo.si_code;
			thread_prstatus.pr_info.si_errno = thread_siginfo.si_errno;

			/* write the prstatus, siginfo and fp regs notes for each thread */
			note_hdr.n_type = NT_PRSTATUS;
			note_hdr.n_namesz = 5;
			note_hdr.n_descsz =  sizeof thread_prstatus;
			written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, file_off);
			if (written < 0) {
				perror("writing prstatus note to core");
				goto thread_done;
			}
			file_off += sizeof note_hdr;
			written = pwrite(outfile_fd, corename, sizeof corename, file_off);
			if (written < 0) {
				perror("writing prstatus note to core");
				goto thread_done;
			}
			file_off += sizeof corename;
			written = pwrite(outfile_fd, &thread_prstatus, sizeof thread_prstatus, file_off);
			if (written < 0) {
				perror("writing prstatus note to core");
				goto thread_done;
			}
			file_off += sizeof thread_prstatus;
			/* 4 byte alignment */
			if (file_off % 4) {
				file_off +=  4 - (file_off % 4);
			}

			note_hdr.n_type = NT_SIGINFO;
			note_hdr.n_namesz = 5;
			note_hdr.n_descsz =  sizeof thread_siginfo;
			written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, file_off);
			if (written < 0) {
				perror("writing siginfo note to core");
				goto thread_done;
			}
			file_off += sizeof note_hdr;
			written = pwrite(outfile_fd, corename, sizeof corename, file_off);
			if (written < 0) {
				perror("writing siginfo note to core");
				goto thread_done;
			}
			file_off += sizeof corename;
			written = pwrite(outfile_fd, &thread_siginfo, sizeof thread_siginfo, file_off);
			if (written < 0) {
				perror("writing siginfo note to core");
				goto thread_done;
			}
			file_off += sizeof thread_siginfo;
			/* 4 byte alignment */
			if (file_off % 4) {
				file_off +=  4 - (file_off % 4);
			}

			note_hdr.n_type = NT_FPREGSET;
			note_hdr.n_namesz = 5;
			note_hdr.n_descsz =  sizeof fpregs;
			written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, file_off);
			if (written < 0) {
				perror("writing fpregset note to core");
				goto thread_done;
			}
			file_off += sizeof note_hdr;
			written = pwrite(outfile_fd, corename, sizeof corename, file_off);
			if (written < 0) {
				perror("writing fpregset note to core");
				goto thread_done;
			}
			file_off += sizeof corename;
			written = pwrite(outfile_fd, &fpregs, sizeof fpregs, file_off);
			if (written < 0) {
				perror("writing fpregset note to core");
				goto thread_done;
			}
			file_off += sizeof fpregs;
			/* 4 byte alignment */
			if (file_off % 4) {
				file_off +=  4 - (file_off % 4);
			}

thread_done:
			if (0 != procfile_fd) {
				close(procfile_fd);
			}
		}
	}
	if (0 == errno) {
		rc = 1;
		*outfile_off = file_off;
	} else {
		perror("failed to write thread notes");
	}

done:
	if (NULL != proc_taskdir) {
		closedir(proc_taskdir);
	}
	if (0 != procfile_fd) {
		close(procfile_fd);
	}
	return rc;
}


/* writes the notes for process info to the corefile
 * returns non zero on success, zero on failure
 */
static int
write_process_notes(struct OMRPortLibrary *portLibrary, int addrsize, int outfile_fd, off_t *outfile_off)
{
	char corename[8] = "CORE"; /* size 8 for alignment */
	ssize_t written = 0;
	off_t file_off = *outfile_off;
	off_t note_start_off = file_off;
#ifdef _LP64
	Elf64_Nhdr note_hdr = {};
#else
	Elf32_Nhdr note_hdr = {};
#endif
	prpsinfo_t prpsinfo = {};
	prstatus_t prstatus = {};

	/* auxillary vector note */
	note_hdr.n_type = NT_AUXV;
	note_hdr.n_namesz = 5;
	note_hdr.n_descsz = 0;
	file_off += sizeof note_hdr;
	written = pwrite(outfile_fd, corename, sizeof corename, file_off);
	if (written < 0) {
		perror("writing auxv note to core");
		return 0;
	}
	file_off += sizeof corename;

	if(!write_note_auxv_data(outfile_fd, &file_off, &note_hdr.n_descsz)) {
		return 0;
	}
	written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, note_start_off);
	if (written < 0) {
		perror("writing auxv note to core");
		return 0;
	}
	/* 4 byte alignment */
	if (file_off % 4) {
		file_off +=  4 - (file_off % 4);
	}

	/* prpsinfo note, general process info */
	note_start_off = file_off;
	note_hdr.n_type = NT_PRPSINFO;
	note_hdr.n_namesz = 5;
	note_hdr.n_descsz = sizeof prpsinfo;
	written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, note_start_off);
	if (written < 0) {
		perror("writing prpsinfo note to core");
		return 0;
	}
	file_off += sizeof note_hdr;
	written = pwrite(outfile_fd, corename, sizeof corename, file_off);
	if (written < 0) {
		perror("writing prpsinfo note to core");
		return 0;
	}
	file_off += sizeof corename;
	if(!gather_process_data(outfile_fd, &prpsinfo, &prstatus)) {
		return 0;
	}
	written = pwrite(outfile_fd, &prpsinfo, sizeof prpsinfo, file_off);
	if (written < 0) {
		perror("writing prpsinfo note to core");
		return 0;
	}
	file_off += sizeof prpsinfo;

	/* 4 byte alignment */
	if (file_off % 4) {
		file_off +=  4 - (file_off % 4);
	}

	if(!write_thread_notes(addrsize, outfile_fd, &file_off, &prstatus)) {
		return 0;
	}

	*outfile_off = file_off;
	return 1;
}

/* writes file note, which contains info for mapped memory segments for the core
 * returns non zero on success, zero on failure
 */
static int
write_file_note(struct OMRPortLibrary *portLibrary, int addrsize, int seg_count, int outfile_fd, off_t *outfile_off)
{
	pid_t ppid = getppid();
	int fd_maps = 0;
	char mapfile_name[32] = "/proc/";
	uint8_t *start_addr = 0;
	uint8_t *end_addr = 0;
	char filePath[EsMaxPath];
	ssize_t written = 0;
	off_t file_off = *outfile_off;
	int i = 0;
	char corename[8] = "CORE"; /* size 8 for alignment */
#ifdef _LP64
	Elf64_Nhdr note_hdr = {};
#else
	Elf32_Nhdr note_hdr = {};
#endif
	long noteinfo[2] = {0}; /* elem 0 is mapped segment count, elem 1 is page size */
	long note_seginfo[3] = {0}; /* start addr, end addr, page offset */


	snprintf(mapfile_name + 6, 32 - 6, "%d/maps", ppid);
	fd_maps = open(mapfile_name, O_RDONLY, 0);
	if (fd_maps < 0) {
		perror("open() on memory map");
		goto error;
	}

	note_hdr.n_type = NT_FILE;
	note_hdr.n_namesz = 5;
	noteinfo[1] = sysconf(_SC_PAGESIZE);
	file_off += sizeof note_hdr;
	written = pwrite(outfile_fd, corename, sizeof corename, file_off);
	if (written < 0) {
		perror("writing file note for mapped segments");
		goto error;
	}
	file_off += sizeof corename;
	file_off += sizeof noteinfo; /* write noteinfo later when we have segment count */
	for (i = 0; i < seg_count; i++) {
		long page_off = 0;
		if (getSharedAndPrivateDataSegments(portLibrary, fd_maps, addrsize, &start_addr, &end_addr, NULL, &page_off, filePath)) {
			if ((strlen(filePath)) > 0 && ('[' != filePath[0])) { /* exclude names like [heap] */
				note_seginfo[0] = (long)start_addr;
				note_seginfo[1] = (long)end_addr;
				note_seginfo[2] = page_off / noteinfo[1];
				written = pwrite(outfile_fd, note_seginfo, sizeof note_seginfo, file_off);
				if (written < 0) {
					perror("writing addresses for mapped segments into file note");
					goto error;
				}
				noteinfo[0] += 1;
				file_off += written;
				note_hdr.n_descsz += written;

			}
		}
	}
	lseek(fd_maps, 0, SEEK_SET);
	for (i = 0; i < seg_count; i++) {
		if (getSharedAndPrivateDataSegments(portLibrary, fd_maps, addrsize, &start_addr, &end_addr, NULL, NULL, filePath)) {
			int filePathLen = strlen(filePath);
			if ((filePathLen > 0) && ('[' != filePath[0])) {
				written = pwrite(outfile_fd, filePath, filePathLen + 1, file_off);
				if (written < 0) {
					perror("writing names for mapped segments into file note");
					goto error;
				}
				file_off += written;
				note_hdr.n_descsz += written;
			}
		}
	}

	written = pwrite(outfile_fd, noteinfo, sizeof noteinfo, (*outfile_off) + (sizeof note_hdr) + 8);
	if (written < 0) {
		perror("writing file note for mapped segments");
		goto error;
	}
	note_hdr.n_descsz += written;

	written = pwrite(outfile_fd, &note_hdr, sizeof note_hdr, *outfile_off);
	if (written < 0) {
		perror("writing file note for mapped segments");
		goto error;
	}
	/* 4 byte alignment */
	if (file_off % 4) {
		file_off +=  4 - (file_off % 4);
	}
	*outfile_off = file_off;

error:
	if (fd_maps > 0) {
		close(fd_maps);
	}
	return file_off == *outfile_off;
}

/* @internal
 * creates a dump from userspace
 * should be called after fork
 */
uintptr_t
userspace_dump_create(struct OMRPortLibrary *portLibrary, char *filename)
{
	uintptr_t rc = 1;
	char *lastSep = NULL;
	char corefile_name[PATH_MAX];
	int corefile_fd = 0;
	pid_t ppid = getppid();
	char taskdir_filename[32] = "/proc/";
	DIR *proc_taskdir = NULL;
	struct dirent *taskdirent = NULL;
	int memfile_fd = 0;
	char memfile_name[32] = "/proc/";
	ssize_t written = 0;
	int i = 0;
	off_t file_off = 0;
	off_t seg_file_off = 0;
#ifdef _LP64
	Elf64_Ehdr elfheader = {};
	Elf64_Phdr notepheader = {};
	Elf64_Phdr *pheaders = NULL;
	int addrsize = 64;
#else
	Elf32_Ehdr elfheader = {};
	Elf32_Ehdr notepheader = {};
	Elf32_Phdr *pheaders = NULL;
	int addrsize = 32;
#endif /* _LP64 */
	uint32_t segment_count = 0;

	/* filename cannot be null */
	if (NULL == filename) {
		return 1;
	}
	/* set default file name if none given */
	if ('\0' == filename[0]) {
		snprintf(filename, PATH_MAX, "core.%u", ppid);
	} else {
		lastSep = strrchr(filename, DIR_SEPARATOR);
		if (NULL != lastSep) {
			strncpy(corefile_name, lastSep + 1, PATH_MAX - 1);
		} else {
			strncpy(corefile_name, filename, PATH_MAX - 1);
		}
	}


	snprintf(taskdir_filename + 6, 32 - 6, "%d/task", ppid);
	proc_taskdir = opendir(taskdir_filename);
	if (NULL == proc_taskdir) {
		perror("opening task dir for process");
		goto done;
	}

	/* attach to all threads in parent process, stopping them and allowing access to memory */
	while ((0 == (errno = 0)) && (NULL != (taskdirent = readdir(proc_taskdir)))) {
		if (DT_DIR == taskdirent->d_type) {
			pid_t tid = strtoul(taskdirent->d_name, NULL, 0);
			/* skip non tid directories */
			if (tid < 1) {
				continue;
			}
			if (-1 == ptrace(PTRACE_ATTACH, tid, NULL, NULL)) {
				perror("failed to attach to parent process threads");
				goto done;
			}

		}
	}
	waitpid(ppid, NULL, 0);


	corefile_fd = open(corefile_name, O_RDWR | O_CREAT | O_EXCL, 0600);
	if (corefile_fd < 0) {
		fprintf(stderr, "failed to open core file: %s ", corefile_name);
		perror("open()");
		rc = corefile_fd;
		goto done;
	}

	snprintf(memfile_name + 6, 32 - 6, "%d/mem", ppid);
	memfile_fd = open(memfile_name, O_RDONLY, 0);
	if (memfile_fd < 0) {
		perror("open() on memory file");
		goto done;
	}


	/* set header values */
	elfheader.e_ident[EI_MAG0] = ELFMAG0;
	elfheader.e_ident[EI_MAG1] = ELFMAG1;
	elfheader.e_ident[EI_MAG2] = ELFMAG2;
	elfheader.e_ident[EI_MAG3] = ELFMAG3;
	elfheader.e_ident[EI_CLASS] = (64 == addrsize) ? ELFCLASS64 : ELFCLASS32;
#ifdef OMR_ENV_LITTLE_ENDIAN
	elfheader.e_ident[EI_DATA] = ELFDATA2LSB;
#else
	elfheader.e_ident[EI_DATA] = ELFDATA2MSB;
#endif /* OMR_ENV_LITTLE_ENDIAN */
	elfheader.e_ident[EI_VERSION] = EV_CURRENT;
	elfheader.e_version = EV_CURRENT;
	elfheader.e_type = ET_CORE;
#ifdef PPC64
	elfheader.e_machine = EM_PPC64;
#elif defined(J9X86)
	elfheader.e_machine = EM_386;
#elif defined(S390) || defined(J9ZOS390)
	elfheader.e_machine = EM_S390;
#elif defined(J9HAMMER)
	elfheader.e_machine = EM_X86_64;
#elif defined(J9ARM)
	elfheader.e_machine = EM_ARM;
#elif defined(J9AARCH64)
	elfheader.e_machine = EM_AARCH64;
#elif defined(RISCV)
	elfheader.e_machine = EM_RISCV;
#else
	elfheader.e_machine = EM_NONE;
#endif /* PPC64 */
	elfheader.e_ehsize = sizeof elfheader;
	elfheader.e_phoff = sizeof elfheader;
	elfheader.e_phentsize = sizeof (*pheaders);

	file_off += elfheader.e_phoff;

	if (!list_segment_headers(portLibrary, addrsize, (void **)&pheaders, &segment_count))  {
		fprintf(stderr, "error reading memory segments from map\n");
		goto done;
	}

	elfheader.e_phnum = segment_count + 1;
	seg_file_off = file_off + elfheader.e_phnum * elfheader.e_phentsize;

	written = pwrite(corefile_fd, &elfheader, elfheader.e_ehsize, 0);
	if (written < 0) {
		perror("error writing elf header");
		rc = written;
	}

	/* write notes */
	notepheader.p_type = PT_NOTE;
	notepheader.p_offset = seg_file_off;

	if (!write_process_notes(portLibrary, addrsize, corefile_fd, &seg_file_off)) {
		fprintf(stderr, "failed to write notes about process info to core\n");
		goto done;
	}

	if(!write_file_note(portLibrary, addrsize, segment_count, corefile_fd, &seg_file_off)) {
		fprintf(stderr, "failed to write file note to core\n");
		goto done;
	}

	notepheader.p_filesz = seg_file_off - notepheader.p_offset;
	written = pwrite(corefile_fd, &notepheader, elfheader.e_phentsize, file_off);
	if (written < 0) {
		perror("failed to write note header to corefile");
		goto done;
	}
	file_off += elfheader.e_phentsize;

	for (i = 0; i < segment_count; i++) {
		pheaders[i].p_offset = seg_file_off;
		if (pheaders[i].p_flags & PF_R) {
			off_t mem_off = pheaders[i].p_vaddr;
			off_t read_size = 65535;
			char mem_buffer[read_size];
			ssize_t bytes_read = 0;

			pheaders[i].p_offset = seg_file_off;
			while (mem_off < pheaders[i].p_vaddr + pheaders[i].p_memsz) {
				size_t to_read = read_size;
				ssize_t read_result;
				if (mem_off + to_read > pheaders[i].p_vaddr + pheaders[i].p_memsz) {
					to_read = pheaders[i].p_vaddr + pheaders[i].p_memsz - mem_off;
				}
				read_result = pread(memfile_fd, mem_buffer, to_read, mem_off);
				if (read_result >= 0) {
					bytes_read += read_result;
					mem_off += read_result;
					written = pwrite(corefile_fd, mem_buffer, read_result, seg_file_off);
					if (written != read_result) {
						perror("failed to write memory segment to corefile");
						goto done;
					}
					seg_file_off += written;
				} else {
					/* skip to next segment if we fail to read this one */
					break;
				}
			}
			pheaders[i].p_filesz = bytes_read;
		}

		written = pwrite(corefile_fd, &pheaders[i], elfheader.e_phentsize, file_off);
		if (written < 0) {
			perror("failed to write memory segment header to corefile");
			goto done;
		}
		file_off += elfheader.e_phentsize;
	}

	rc = 0;

done:
	if (corefile_fd > 0) {
		close(corefile_fd);
		if (rc) {
			remove(corefile_name);
		}
	}
	rewinddir(proc_taskdir);
	while ((0 == (errno = 0)) && (NULL != (taskdirent = readdir(proc_taskdir)))) {
		if (DT_DIR == taskdirent->d_type) {
			pid_t tid = strtoul(taskdirent->d_name, NULL, 0);
			/* skip non tid directories */
			if (tid < 1) {
				continue;
			}
			ptrace(PTRACE_DETACH, tid, NULL, NULL); /* failure doesn't matter here */
		}
	}
	if (NULL != proc_taskdir) {
		closedir(proc_taskdir);
	}
	if (NULL != pheaders) {
		free(pheaders);
	}
	return rc;
}
